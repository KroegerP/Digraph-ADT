// Homework 4
// EECE 4040
// Group 3 - Peter Kroeger, Reagan Maddox, Michael Limberg

#include <iostream>
#include <sstream>
#include <fstream>
#include <string.h>
#include <vector>
#include <stack>

using namespace std;

struct Task {
    Task(): taskNumber(0), taskName(""), next(NULL) {}
    Task(int taskNumber, string taskName) : taskNumber(taskNumber), taskName(taskName), next(NULL) {}
    int taskNumber;
    string taskName;
    Task* next;
};

struct OrderPair {
    OrderPair(int firstNum, int secondNum): firstNum(firstNum), secondNum(secondNum) {}
    int firstNum;
    int secondNum;
};

// struct Node {
//     Node(): task(){}
//     Node(Task myTask): task(myTask) {}
//     Task task;
//     Node* next;
// };

class Digraph {
    public:
        Digraph(){}
        Digraph(vector<Task*> adjList, vector<OrderPair> myPairs): adjList(adjList), myPairs(myPairs) { CreateDAG(); }
        ~Digraph(){}
        void AddEdge(int src, int dest); //Add edge to the end of the head LL of the source in the adjacency list
        void DelEdge(int src, int dest); //Search for the edge given, remove the edge from the adjacency list
        void CreateDAG();
        void DepthFirstSearch(int pos, vector<bool> &mark, Task* sortedTasks);
        void TopologicalSort(); //Implement using DFT, store each task in the sort in a LL
        bool AcyclicCheck(); 
        void PrintSort(Task* rootNode);
    private:
        vector<Task*> adjList;
        vector<OrderPair> myPairs;
};

void Digraph::AddEdge(int src, int dest) {
    Task* curNode = adjList[src - 1];
    Task* destNode = new Task(adjList[dest - 1]->taskNumber, adjList[dest - 1]->taskName);
    while(curNode -> next != NULL) {   //Iterate to the end of the linked list for the src node in the adjacency list
        curNode = curNode -> next;
    }
    curNode -> next = destNode;       //Add the destination node to the linked list chain
}

// void Digraph::DelEdge(int src, int dest) {
//     Task* curNode = adjList[src - 1];
//     Task* destNode = adjList[dest - 1];
//     while(curNode -> next != destNode) {  //Iterate until the node to be deleted is the next node of the linked list
//         curNode = curNode -> next;
//     }
//     curNode -> next = NULL;                //Set the next node to NULL to remove it from the list
// }

void Digraph::CreateDAG() {
    for(int i = 0; i < myPairs.size(); i++) {
        AddEdge(myPairs[i].firstNum, myPairs[i].secondNum);
        // if(AcyclicCheck()) {
        //     DelEdge(myPairs[i].firstNum, myPairs[i].secondNum);
        // }
    }
    cout << adjList.size() << endl;
    for(int i = 0; i < adjList.size(); i++) {
        cout << "Task " << i+1 << ": " << adjList[i] -> taskName << " Adj list precedences: " << endl;
        Task* curNode = adjList[i];
        while(curNode -> next != NULL) {
            cout << curNode -> next -> taskNumber << ": " << curNode -> next->taskName << endl;
            curNode = curNode -> next;
        }
    }
}

void Digraph::DepthFirstSearch(int pos, vector<bool> &mark, Task* sortedTasks) {
    mark[pos] = true;
    Task* curNode = adjList[pos];
    int listPos = curNode->taskNumber - 1;
    while(curNode -> next != NULL){         //Iterate through the current head in the adjacency list, if a member isn't visited, visit it
        curNode = curNode -> next;
        listPos = curNode->taskNumber - 1;
        if(!mark[listPos]) {
            DepthFirstSearch(listPos, mark, sortedTasks);   // Visiting a node pointed to in a chain on a adjacency list head
        }
    }
    Task* orderNode = sortedTasks;
    Task* taskNode = new Task(adjList[pos]->taskNumber, adjList[pos]->taskName);
    while(orderNode->next != NULL) {
        orderNode = orderNode->next;    //Iterate though the sorted Task list, add the newly sorted task to the end of the list
    }
    orderNode->next = taskNode;
}

void Digraph::TopologicalSort() { // Perform a DFT on the Digraph, do a DFS on every unvisited, order for sort is the reverse of the visits
    vector<bool> mark;
    stack<int> taskOrder;
    Task* sortedTasks = new Task;

    for(int i = 0; i<adjList.size(); i++) {
        mark.push_back(0);
    }
    for(int i = 0; i<adjList.size(); i++) {
        if(!mark[i]) {
            DepthFirstSearch(i, mark, sortedTasks);
        }
    }
    cout << endl << "Task Order after sorting (Bottom -> Top): " << endl;
    PrintSort(sortedTasks);     //Printing the LL generated by the Topological Sort
}

bool Digraph::AcyclicCheck() {
    bool result = false;

    return result;
}

void Digraph::PrintSort(Task* rootNode) { // Recursively go through the Linked list of sorted tasks and print out in reverse order
    if(rootNode->next != NULL){
        PrintSort(rootNode->next);
    }
    if(rootNode->taskNumber == 0) {
        return;
    }
    cout << "Task " << rootNode->taskNumber << ": " << rootNode->taskName << endl;
}

int main()
{
    int ans, firstNum, secondNum;
    string curTaskName, taskOrder, taskCount;

    cout << "How many tasks do you want to input?" << endl;
    getline(cin,taskCount);
    ans = atoi(taskCount.c_str());

    // Creates vector adjList of Task type with size that the user inputs
    vector<Task*> adjList;
    string* taskArr = new string[ans];

    // The user sees and interacts with the tasks with numbering 1 through n
    // The back-end sees and interacts with the tasks with numbering 0 through (n-1)
    cout << "Please enter your task names:" << endl;
    for(int i=0; i < ans; i++){
        cout << "Task " << i+1 << ": "; 
        getline(cin, curTaskName);
        taskArr[i] = curTaskName;
        Task* newTask = new Task(i+1, curTaskName);
        adjList.push_back(newTask);
    }
    cout << endl;

    vector<OrderPair> myPairs;
    int orderPairAns = 1;

    // Enter the order pair relationships for tasks
    while(orderPairAns != 0) {
        cout << "Please input your task order pair as two numbers with a space in between. The order indicates of inputs represents the order the tasks will be done in: ";
        cin >> firstNum >> secondNum;

        // Check validity of pairs
        if(firstNum > 0 && firstNum < (ans + 1) && secondNum > 0 && secondNum < (ans + 1)){
            OrderPair curPair(firstNum, secondNum);
            myPairs.push_back(curPair);
        }
        else
            cout << "Inputted pair is not valid. Your input has been disregarded." << endl;

        cout << "Do you want to order another task? 1 for Yes 0 for No: ";
        cin >> orderPairAns;
    }

    cout << endl; // Spacer line

    // Creating Digraph
    Digraph myDigraph(adjList, myPairs);

    myDigraph.TopologicalSort();
    
    return 0;
}